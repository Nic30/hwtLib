from hwt.code import log2ceil, connect
from hwt.hdlObjects.constants import INTF_DIRECTION
from hwt.hdlObjects.types.array import Array
from hwt.hdlObjects.types.structUtils import FrameTemplate
from hwt.interfaces.std import BramPort_withoutClk, RegCntrl, Signal, VldSynced
from hwt.synthesizer.interfaceLevel.unit import Unit
from hwt.synthesizer.param import evalParam
from hwtLib.abstract.addrSpace import AddrSpaceItem


class BusConverter(Unit):
    def __init__(self, structTemplate):
        """
        @param structTemplate:
                    interface types for field type:
                        primitive types like Bits -> RegCntrl interface
                        Array -> BramPort_withoutClk interface
        """
        Unit.__init__(self)
        self.STRUCT_TEMPLATE = structTemplate

    def suggestedAddrWidth(self):
        bitSize = self.STRUCT_TEMPLATE.bit_length()
        AW = evalParam(self.ADDR_WIDTH).val
        maxAddr = bitSize // AW

        if bitSize % AW != 0:
            maxAddr += self.getWordAddrStep()

        return maxAddr.bit_length()
    
    def getWordAddrStep(self):
        AW = evalParam(self.ADDR_WIDTH).val
        return AW // 8
    
    def _parseAddrMap(self):
        self.ADRESS_MAP = []
        f = FrameTemplate.fromHStruct(self.STRUCT_TEMPLATE)
        f.resolveFieldPossitionsInFrame(evalParam(self.DATA_WIDTH).val, disolveArrays=False)
        addrStep = self.getWordAddrStep()
        
        for indx, fields in f.walkWords():
            if len(fields) > 1:
                raise NotImplementedError("Packing of fields not implemented")
            for field in fields:
                if field.name is None:
                    continue
                assert len(field.appearsInWords) == 1 
                if isinstance(field.type, Array):
                    size = evalParam(field.type.size).val
                else:
                    size = None
                asi = AddrSpaceItem(indx * addrStep, field.name, size)
                self.ADRESS_MAP.append(asi)    
        
        assert self.ADRESS_MAP
        
    def decorateWithConvertedInterfaces(self):
        self._parseAddrMap()

        self._directlyMapped = []
        self._bramPortMapped = []

        for addrItem in self.ADRESS_MAP:
            if addrItem.size is None:
                addrItem.size = 1
                p = RegCntrl()
                p._replaceParam("DATA_WIDTH", self.DATA_WIDTH)
                self._directlyMapped.append(addrItem)
            else:
                p = BramPort_withoutClk()
                p._replaceParam("DATA_WIDTH", self.DATA_WIDTH)
                p.ADDR_WIDTH.set(log2ceil(addrItem.size - 1))
                self._bramPortMapped.append(addrItem)

            addrItem.port = p
            p._addrSpaceItem = addrItem

            setattr(self, addrItem.name, p)

    @classmethod
    def _resolveRegFiles(cls, prefix, addrStep, regs):
        """
        generator of tuple ( (addr, name), interface ) where interface is None when register is specified by name instead of interface
        @param regs: iterable of tuples
                 (addr, name) or
                 (addr, name, interfaces)

                 if addr is None addr is automatically generated by addrStep
        @param addrStep: step in addr between registers
        @param prefix: prefix for register name
        """
        nextFreeAddr = 0x0
        for reg in regs:
            if len(reg) == 3 and isinstance(reg[2], (list, tuple)):
                addr, name, interfaces = reg

                if addr is None:
                    addr = nextFreeAddr

                for i, intf in enumerate(interfaces):
                    # we expect all to be specified by interface because there
                    # should not be any any register without connection in subunits
                    fieldAddr = addr + i * addrStep
                    yield (fieldAddr, prefix + name + intf._name), intf
                    nextFreeAddr += addrStep

            else:
                addr, name = reg
                if addr is None:
                    addr = nextFreeAddr
                else:
                    nextFreeAddr = addr
                nextFreeAddr += addrStep

                yield (addr, prefix + name), None

    @classmethod
    def _buildForAddrSpace(cls, parent, onParentName, bus, busDataWidth, configFn, addrSpace):
        regsFlatten = []
        intfMap = {}
        # build flatten register map
        for reg, intf in cls._resolveRegFiles("", evalParam(busDataWidth).val // 8, addrSpace):
            regsFlatten.append(reg)
            if intf is not None:
                _, name = reg
                intfMap[name] = intf

        # instantiate converter
        conv = cls(regsFlatten)
        configFn(conv)

        setattr(parent, onParentName, conv)

        conv.bus ** bus

        # connect interfaces as was specified by register map
        for regName, intf in intfMap.items():
            convIntf = getattr(conv, regName)

            if isinstance(intf, Signal):
                assert intf._direction == INTF_DIRECTION.MASTER
                connect(intf, convIntf.din, fit=True)

            elif isinstance(intf, RegCntrl):
                assert intf._direction == INTF_DIRECTION.SLAVE
                connect(convIntf, intf, fit=True)

            elif isinstance(intf, VldSynced):
                assert intf._direction == INTF_DIRECTION.SLAVE
                connect(convIntf.dout, intf, fit=True)

            else:
                raise NotImplementedError()
