from copy import copy
from typing import Optional, List, Dict

from hwt.hdl.frameTmpl import FrameTmpl
from hwt.hdl.transTmpl import TransTmpl
from hwt.hdl.types.hdlType import HdlType
from hwt.hdl.types.stream import HStream
from hwt.hdl.types.struct import HStructField, HStruct
from hwt.pyUtils.arrayQuery import iter_with_last
from hwt.hdl.types.bits import Bits


class TemplateConfigured():
    """
    Class with functions for extracting metadata from frame template/HdlType.
    Used for resolving of data mapping between abstract type and physical interface.
    """
    def __init__(self,
                 structT: HdlType,
                 tmpl: Optional[TransTmpl]=None,
                 frames: Optional[List[FrameTmpl]]=None):
        """
        :param structT: instance of HStruct used as template for this frame
            If name is None no input port is generated and space
            is filled with invalid values, litle-endian encoding,
            supported types of interfaces are: Handshaked, Signal
            can be also instance of FrameTmpl
        :param tmpl: instance of TransTmpl for this structT
        :param frames: list of FrameTmpl instances for this tmpl
        :note: if tmpl and frames are None they are resolved
            from structT parseTemplate
        """
        if tmpl is not None:
            assert frames is not None, \
                "tmpl and frames can be used only together"
        else:
            assert frames is None, "tmpl and frames can be used only together"

        self._structT = structT
        self._tmpl = tmpl
        self._frames = frames

    def parseTemplate(self):
        if self._tmpl is None:
            self._tmpl = TransTmpl(self._structT)

        if self._frames is None:
            DW = int(self.DATA_WIDTH)
            frames = FrameTmpl.framesFromTransTmpl(self._tmpl,
                                                   DW)
            self._frames = list(frames)

    def chainFrameWords(self):
        offset = 0
        for f in self._frames:
            wi = 0
            for last, (wi, w) in iter_with_last(f.walkWords(showPadding=True)):
                yield (offset + wi, w, last)
            offset += wi + 1


def separate_footers(t: HdlType, field_map: Dict[HStructField, HStructField]):
    """
    In this context the footer means the data behind the data of non constant size.
    The type is splited to a multiple types where variable size data may appear only
    as a last field.

    :note: e.g. in HStruct(
        (HStream(Bits(8)), "data"),
        (Bits(32), "fcs"),
        ) the "fcs" is the footer
    """
    if isinstance(t, HStruct):
        # fields which were generated by field spliting and are not yet in output HStruct
        leftovers = []
        any_split = False
        for f in t.fields:
            for is_const_size, _t in separate_footers(f.dtype, field_map):
                if t is f.dtype:
                    leftovers.append(f)
                else:
                    # the type was spltited somewhere
                    _f = copy(f)
                    _f.dtype = _t
                    leftovers.append(_f)
                    if not is_const_size:
                        # create a new HStruct from previous fields
                        new_t = HStruct(*leftovers, name=t.name)
                        leftovers.clear()
                        yield (False, new_t)
                        any_split = True
        if any_split:
            if leftovers:
                new_t = HStruct(*leftovers, name=t.name)
                yield (True, new_t)
        else:
            yield (True, t)

    elif isinstance(t, HStream):
        try:
            t.bit_length()
            yield (True, t)
        except TypeError:
            yield (False, t)
    else:
        yield (True, t)


def to_primitive_stream_t(t: HdlType):
    """
    Converty type to a HStream of Bits
    With propper frame len, offset etc.
    """
    if isinstance(t, HStruct) and len(t.fields) == 1:
        return to_primitive_stream_t(t.fields[0].dtype)
    frame_len = (1, 1)
    start_offsets = [0, ]
    if isinstance(t, HStream):
        e_t = t.element_t
        if isinstance(e_t, Bits):
            return t
        else:
            frame_len = t.frame_len
            start_offsets = t.start_offsets
            t = e_t

    try:
        bit_len = t.bit_length()
    except TypeError:
        bit_len = None

    if bit_len is not None:
        return HStream(Bits(bit_len),
                       frame_len=frame_len,
                       start_offsets=start_offsets)
    else:
        raise NotImplementedError(t)
